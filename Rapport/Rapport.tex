\documentclass[12pt, openany]{report}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[a4paper,left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\usepackage[frenchb]{babel}
\usepackage{libertine}
\usepackage[pdftex]{graphicx}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{color}


\usepackage[colorlinks=true,linkcolor=red]{hyperref}
\usepackage[nottoc, notlof, notlot]{tocbibind}

\usepackage{cite}

\setlength{\parindent}{1cm}
\setlength{\parskip}{1ex plus 0.5ex minus 0.2ex}
\newcommand{\hsp}{\hspace{20pt}}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
\begin{document}

\begin{titlepage}
  \begin{sffamily}
  \begin{center}

    % Upper part of the page. The '~' is needed because \\
    % only works if a paragraph has started.
    \includegraphics[scale=0.2]{Images/UMONS+txt.png}   ~\\[1.5cm]
    


    \HRule \\[0.4cm]
    { \huge \bfseries Projet de Software Evolution - JPacman\\[0.4cm] }
    \HRule \\[2cm]
    \includegraphics[scale=0.5]{Images/Pac-Man.jpg}~\\[1.5cm] 

    
    

    % Author and supervisor
    \begin{minipage}{0.4\textwidth}
      \begin{flushleft} \large
        \emph{Réalisateurs :\\} Damien \textsc{Legay}\\ Adrien \textsc{Coppens}\\ Nicolas \textsc{Leemans}\\
        
      \end{flushleft}
    \end{minipage}
    \begin{minipage}{0.4\textwidth}
      \begin{flushright} \large
        \emph{Enseignant :} M. Tom  \textsc{Mens}\\
        \emph{Date de remise : } 9 mai 2016\\
        \emph{Année d'étude : } Master 1
      \end{flushright}
    \end{minipage}

    \vfill

    % Bottom of the page
    {\large Année académique 2015 - 2016}
	
  \end{center}
  \end{sffamily}
\end{titlepage}




\newpage

	\renewcommand{\thesection}{\arabic{section}}
	\tableofcontents
	\newpage
	\setcounter{secnumdepth}{3}
	\setcounter{tocdepth}{4}
	

\section{Introduction}
%todo: uniformiser : \textit{Class#Method} ? (==javadoc) + préciser convention au début du rapport
Ce projet, effectué dans le cadre du cours de "Software Evolution" dispensé par Monsieur Tom Mens durant l'année académique 2015-2016, a pour but de mettre en pratique les concepts d'évolution logicielles vus au cours théorique. Il consiste à analyser et à étendre un projet en effectuant un contrôle de la qualité au travers de différentes métriques, le \textit{"refactoring"} du code source, ainsi que l'implémentation de nouvelles fonctionnalités. Le projet concerné s'appelle JPacman\footnote{https://github.com/SERG-Delft/jpacman-framework}. Il s'agit d'une implémentation très basique du jeu Pacman en Java, créé par l'équipe  du professeur Arie van Deursen, Delft University of Technology (Pays-Bas).
 JPacman contient plusieurs simplifications par rapport au jeu Pac-Man original. Le jeu consiste à déplacer Pac-Man, un personnage qui, vu de profil, ressemble à un diagramme circulaire à l’intérieur d’un labyrinthe, afin de lui faire manger toutes les pac-gommes qui s’y trouvent en évitant d’être touché par des fantômes.
 
 Ce rapport s'organise en plusieurs chapitres : dans un premier chapitre, ...
 
\section{Extension du projet et ajout de tests unitaires pour cette extension }

\subsection{Extension du logiciel}

La première partie de ce projet consistait à étendre la version initial de JPacman en ajoutant de nouvelles fonctionnalités et en suivant un processus de développement dirigé par les tests. De nouveaux tests unitaires ont donc été ajoutés pour chaque fonctionnalité afin de vérifier que le comportement initial du logiciel n’a pas été altéré. 

Chaque membre du groupe a donc implémenté une des fonctionnalités suivantes :
\begin{itemize}
\item L'implémentation d'un score (réalisée par Damien Legay)
\item L'implémentation d'une série de labyrinthes (réalisée par Adrien Coppens)
\item L'implémentation d'une intelligence artificielle pour pacman (réalisée par Nicolas Leemans)

\end{itemize}

\subsubsection{Fonctionnalité "Score"}
\subsubsection{Fonctionnalité "Série de labyrinthes"}
Les ajouts à effectuer pour cette extension sont :
\begin{enumerate}
	\item Système de vies pour Pac-man, au nombre de 3 initialement,
	\item Gain d'une vie supplémentaire tous les 10000 points,
	\item Téléportation de Pac-man lorsqu'il est tué par un fantôme (et qu'il lui reste au moins une vie),
	\item Ajouts d'autres niveaux en préservant la vie et le score de Pac-man lors du passage au niveau suivant (ce qui se produit lorsque toutes les gommes ont été ramassées),
	\item Sauvegarde du \og meilleur \fg \, niveau atteint pour pouvoir, par la suite, débuter directement à un niveau précédemment accédé.
\end{enumerate} 
%todo: formater ce texte pour le rendre lisible

$(1)$ a simplement été réalisé par l'ajout d'un champ \mbox{\textit{lives}} dans la classe \mbox{\textit{Player}} et en faisant en sorte que, lors de la collision avec un fantôme, Pac-man perde une vie plutôt que de mourir (appel à \mbox{\textit{Player\#loseLife}} plutôt qu'à \mbox{\textit{Player\#setAlive(false)}}).

De la même manière, la réalisation de $(2)$ a pu se faire rapidement, en ajoutant une méthode \mbox{\textit{Player\#checkNewLifeThreshold(int)}}, appelée à chaque fois que le joueur reçoit des points. Cette méthode se contente de vérifier si le seuil a été dépassé et ajoute une vie au joueur le cas échéant.

L'ajout $(3)$ a demandé plus de réflexion quant à la manière de l'implémenter. En effet, pour permettre une téléportation \og safe \fg , il est nécessaire d'avoir connaissance du niveau (le \mbox{\textit{Board}}), alors que le joueur est, en l'état, le seul à être au courant de sa mort.
Il a été choisi ici d'implémenter un design pattern \mbox{\textit{Observer}}, via une interface \mbox{\textit{PlayerListener}}, qui ne contient qu'une méthode \mbox{\textit{onPlayerLoseLife(Player)}} mais qui pourrait être facilement étendue (pour par exemple permettre l'affichage d'une notification lorsque le joueur reçoit une vie).
Via l'implémentation de \mbox{\textit{PlayerListener}}, \mbox{\textit{Level}} est capable de réagir à la mort du joueur et, puisqu'il possède une référence vers le \mbox{\textit{Board}}, de le téléporter. L'énoncé demande une téléportation \textit{aléatoire} à une distance de 4 cases de tout fantôme, il sera fait utilisation de la distance Manhattan\footnote{\url{https://en.wiktionary.org/wiki/Manhattan_distance}}. Lorsque Pac-man meurt, une liste des cases \og possibles \fg \, est récupérée via la méthode \mbox{\textit{Level\#getPossibleSquares()}} et le joueur est effectivement transporté aléatoirement sur l'une de celles-ci. Afin de déterminer si une case est \og possible \fg , on s'assure qu'elle soit accessible (qu'elle ne corresponde pas à un mur par exemple) et \og safe \fg , c'est-à-dire qu'aucun fantôme ne soit à portée.
Pour ce faire, pour toute case accessible, on vérifie les occupants des cases \og voisines \fg \, en s'assurant qu'elles ne contiennent pas de fantôme. En réalité, puisque les cases situées à une distance Manhattan d'une case donnée forment une sorte de losange, on itère sur le rectangle des cases situées à une distance horizontale et verticale inférieure à 4, en filtrant ensuite les cases trop éloignées en distance Manhattan. Cette situation est représentée à la figure \ref{manhattan}, dans laquelle on s'intéresse à une distance Manhattan de 4 cases à partir de la case {\color{blue}{bleue}}. Les cases à une telle distance sont en {\color{green}{vert}} alors que les cases filtrées sont en {\color{red}{rouge}} (les cases noires ne sont pas du tout prises en compte).
\begin{figure}[h]
	\centering
	\includegraphics[width=6cm]{Images/manhattan.jpg}
	\caption{\label{manhattan} Cases à une distance Manhattan de 4}
\end{figure}

$(4)$ était également problématique puisque \mbox{\textit{Level}} et \mbox{\textit{Game}} étaient les seuls à être au courant de la réussite d'un niveau, alors que les méthodes permettant le chargement d'un niveau (via \mbox{\textit{MapParser}}) se trouvaient dans \mbox{\textit{Launcher}}. La solution logique semblait être de déplacer les méthodes appelant \mbox{\textit{MapParser}} de \mbox{\textit{Launcher}} vers \mbox{\textit{Game}} mais il a été décidé d'attendre la fusion des différentes extensions individuelles pour réaliser ce changement. Nous voulions en réalité éviter les conflits potentiels lors de la fusion puisque ce \og transfert \fg de méthodes demande un nombre important de modifications dans le code d'origine. En attendant la fusion, on a simplement fait en sorte que \mbox{\textit{Game}} aie la référence vers une instance de \mbox{\textit{Launcher}}.

$(5)$ posait également problème, non pas sur sa réalisation en soi mais, ici, sur la redondance et la future intégration avec le système de profil de l'extension \og Score \fg . Pour cette fonctionnalité, il a été choisi de simuler l'authentification en respectant des conventions de nommage communes. On fournira ici les méthodes permettant, une fois qu'a été récupéré le niveau maximum atteint par un joueur, d'ajouter des boutons de sélection/chargement de niveau tout en réinitialisant le score et les vies du joueur.
Pour les ajouts $(4)$ et $(5)$, il a été nécessaire d'ajouter des fichiers de niveaux supplémentaires. Puisque la démarche était fastidieuse, une fonctionnalité \og bonus \fg \, a été implémentée : la génération de fichiers de niveaux au format Pac-man à partir d'une image. En effet, en attribuant une couleur à chaque type d'élément du jeu,  une image peut être convertie en un fichier texte équivalent et \og lisible \fg \, par \mbox{\textit{MapParser}}. Cela permet de créer des niveaux rapidement avec n'importe quel logiciel d'édition d'image puisqu'ils permettent d'utiliser des fonctionnalités comme le \og remplissage \fg d'une zone, qui évite donc d'entrer le même caractère un grand nombre de fois (on obtient également un rendu visuel plus clair que le fichier texte équivalent). La figure \ref{map_generator} montre un exemple de résultat de conversion d'une image en son niveau équivalent dans JPacman.
\begin{figure}[h]
	\centering
	\includegraphics[width=13cm]{Images/mapgenerator.jpg}
	\caption{\label{map_generator} Génération d'un niveau à partir d'une image}
\end{figure}

\subsubsection{Fonctionnalité "IA pour Pacman"}

L'objectif de cette fonctionnalité est d'intégrer, au code existant, une intelligence artificielle pour Pacman afin qu'il puisse jouer de façon autonome tout en optimisant son score. En début de partie, le joueur doit pouvoir choisir entre contrôler Pacman manuellement ou être un spectateur passif de la partie en choisissant l'intelligence artificielle qui contrôlera Pacman à la place du joueur. Pour mettre en place cela, il a été recommandé d'utiliser un design pattern nommé "Strategy". Le design pattern "Strategy" consiste à définir un comportement (appelée "strategie") qui va permettre de différencier l'utilisation entre l'IA ou le contrôle manuel. Ce design pattern offre également une flexibilité pour modifier la stratégie suivie très facilement.











\section{Refactorings avant analyse}
%todo: ce qui était prévu juste après merge, qu'on avait laissé tel quel ds les parties individuelles pr éviter au maximum les conflits lors de l'intégration des PR

\subsection{Fusion des tests sur \og Player \fg}
%Des tests avaient été effectués par 2 d’entre nous et lors de la fusion, nous avions simplement fusionné ceux-ci en ignorant la redondance de variables d’instances. L’un des 2 tests n’utilisant pas les \og mocks \fg, une légère adaptation a été nécessaire pour que le mock de fantôme retourne une valeur lors de l’appel à \og Ghost#getIdentity() \fg.
\subsection{Déplacement de la variable retenant le niveau courant de \og Level \fg vers \og Game \fg}
%Plus logique et évite un problème de \og feature envy \fg 
\subsection{Déplacement des méthodes concernant le \og map parser \fg de \og Launcher \fg vers \og Game \fg}
%Plus logique et évite que \og Game \fg doive avoir une référence vers le \og Launcher \fg qui l’a créé (pour pouvoir charger le niveau suivant en cas de \og victoire \fg)
%A nécessité de passer des méthodes/variables en \og static \fg (une partie des accesseurs aux \og Factories \fg de \og Launcher \fg puisque \og MapParser \fg en a besoin) mais cela reste logique puisque ces méthodes/variables sont en effet uniques au runtime.









\section{Analyse de la qualité du code source}

Dans ce chapitre, nous allons comparer la qualité du code source qui intègre toutes les extensions individuelles avec la qualité du code source de la version de départ de JPacman. Pour pouvoir effectuer cette comparaison, il va, tout d'abord, falloir effectuer des analyses sur la qualité du code source des deux versions en utilisant différents types d'analyses et de techniques. Pour effectuer cette analyse, nous ferons appel à plusieurs outils d'analyse de qualité que nous détaillerons par la suite. Cette phase d'analyse se déroulera en trois étapes : une analyse statique et dynamique du code ainsi qu'une analyse de la qualité par plusieurs métriques logicielles qui peuvent aider à déceler de mauvaises pratiques. 

\section{Analyse statique}
\subsection{Code dupliqué}
Puisque nous utilisons tous les 3 IntelliJ IDEA, l'outil intégré a été utilisé dans un premier temps. La figure \ref{duplicate} montre les résultats obtenus via cette analyse.
On peut noter que les détections ayant un \og coût \fg \, inférieur à $\sim$20 ne sont pas réellement préoccupantes. Pour exemple, les lignes suivantes, extraites de \textit{SquareCoordinateTest}, sont considérées comme dupliquées par l'outil avec un score de 10 :
\begin{lstlisting}[language=java]
assertEquals(square.getSquareAt(Direction.WEST).getY(), 15);
assertEquals(square.getSquareAt(Direction.EAST).getY(), 15);
\end{lstlisting}
Il s'agit en effet de 2 lignes très similaires mais il ne nous a pas semblé intéressant de supprimer ce type de duplicat. 
%todo: actions en réaction aux duplicats évitables et significatifs (coût > 25? CPD?)
Dans un second temps, nous avons analysé le code via \textit{CPD} inclus dans \textit{PMD} et qui était utilisé dans la suite de rapports à générer par \textit{Maven}. Le seul dupliqué signalé par cet outil concerne la classe \textit{AStarPathTest} pour laquelle les méthodes \textit{hTest} et \textit{gTest} contiennent en effet toutes deux ce bloc de code :
\begin{lstlisting}[language=java]
final AStarPath aStarPath = new AStarPath(game);

assertNotNull(aStarPath);
final Player player = game.getPlayers().get(0);
final Square square = player.getSquare();

assertNotNull(player);
assertNotNull(square);

final Square origin = player.getSquare();
final Square destination = player.getSquare().getSquareAt(Direction.EAST);
final Square destination2 = player.getSquare().getSquareAt(Direction.EAST).getSquareAt(Direction.EAST);

final Square destination3 = player.getSquare().getSquareAt(Direction.WEST);
final Square destination4 = player.getSquare().getSquareAt(Direction.WEST).getSquareAt(Direction.WEST);
\end{lstlisting}
%todo: nicolas: action entreprise (extract method?)

\begin{figure}[h]
	\centering
	\includegraphics{Images/duplicate_analysis.JPG}
	\caption{\label{duplicate} Recherche de code dupliqué via l'outil intégré à \textit{IntelliJ IDEA}}
\end{figure}

\subsection{CheckStyle}
Egalement intégré dans la suite d'analyses à effectuer via \textit{Maven}, \textit{CheckStyle} a été utilisé avec le \og ruleset \fg \, présent dans la version du code d'origine.
Aucune erreur n'a été détectée mais de nombreux \og warnings \fg \, sont cependant présents (plus de 500). Par ordre de nombre de \og violations \fg :
\begin{itemize}
	\item 148 violations de type \textit{JavadocStyle} : en réalité toutes des \og First sentence should end with a period. \fg $\rightarrow$ réglé. 
	\item 110 violations de type \textit{MagicNumber} $\rightarrow$ constantes extraites là où cela avait du sens, sauf pour les tests où un tel refactoring nous semblait inutile, nous avons donc supprimé les \og warnings \fg \, pour ceux-ci.
	\item 104 violations de type \textit{LineLength} $\rightarrow$ retours à la ligne là où c'était nécessaire.
	\item 63 violations de type \textit{NeedBraces} $\rightarrow$ bien que nous ne soyons pas tous d'accord sur la valeur ajoutée d'une telle convention, nous avons ajouté les crochets là où \textit{CheckStyle} le demandait.
	\item 35 violations de type \textit{AvoidStarImport} $\rightarrow$ encore une fois désactivés car nous utilisons la fonction \og optimize imports \fg \, d'\textit{IntelliJ IDEA} qui regroupe parfois des imports en un unique via cette notation.
	\item Des violations relatives à des éléments de javadoc manquants $\rightarrow$ ajoutés.
	\item Des violations relatives à des tableaux déclarés à la \og mode C \fg \, plutôt qu' à la \og mode Java \fg $\rightarrow$ modifiés.
	\item D'autres violations plus \og isolées \fg \, non reprises ici.
\end{itemize}

\subsection{IntelliJ Code inspection}
\subsubsection{IntelliJ dit que la condition impliquant QUICK\_WIN est \og pointless \fg} 
%Puisque la variable mise à true ou false dans le code, c’est effectivement le cas sur le code compilé, pas dans le code source puisqu’on veut pouvoir le changer. Note qu’on pourrait aussi permettre de set ça en paramètre au lancement du prog (option type \og --quick \fg)
\subsubsection{Changements mineurs (\og scope \fg de méthodes/variables, variables qui peuvent être \og final \fg)}
\subsubsection{Dans le code de base, beaucoup de \og warnings \fg sur des \og problèmes de modernité \fg}
%for indexé plutôt que foreach, méthode anonyme classique plutôt que lambda, etc

\subsection{PMD}
\subsubsection{Déplacement des méthodes liées à la récupération des cases \og safe \fg pour téléporter le joueur de Level vers Board}
%Plus logique et évite un problème de \og feature envy \fg desdites méthodes
\subsubsection{Problème détecté par PMD : Level == godclass et PacManhatanAI aussi}
%Signifie que :
%1.	Level a une \og cohésion interne \fg faible, nous sommes en effet très loin du seuil de 1/3 mais cela devait également être le cas dans la version de base
%2.	Level accède à des attributs appartenant à trop de classes étrangères, encore une fois, peu de changements à ce niveau là par rapport à la version de base
%3.	Level est \og trop complexe par rapport à sa taille \fg : le problème ici semble venir de PMD qui, d’après la règle définie sur https://pmd.github.io/pmd-5.4.1/pmd-java/xref/net/sourceforge/pmd/lang/java/rule/design/GodClassRule.html attribue effectivement une valeur de complexité mais à aucun moment ne prend en compte la \og taille \fg de la classe.
%Etant donné que Level comprend beaucoup de méthodes, la complexité est naturellement élevée.
%todo: couplage/cohésion plus en détail? 
%todo: matrice de dépendance?
%todo: autres choses ? taille/complexité en fonction des classes ? (check si pas déjà fait dans les rapports maven d'abord)
\section{Analyse dynamique}
%todo: couverture code
%todo: couverture tests
%todo: profilage (CPU/RAM)
\section{Mesure de la qualité du logiciel} 
%todo: ? différence avec analyse de qualité ? voulais-tu créer ici la section "analyse de la qualité dans le temps" (régression avec par ex. R, comme en TP) ?
%todo: lier "analyse dans le temps" avec les lois vues en cours
\section{Notes diverses et guide d'utilisation}
\subsection{Maven}
Le projet utilisant Maven\footnote{\url{https://maven.apache.org/}}, il est très facile de compiler le code, de l'analyser avec les outils prévus ou d'exécuter la suite de tests.
En considérant que cet outil est correctement installé sur votre machine et en plaçant un terminal (une invite de commande ou autre terme décrivant une \og console \fg \, sur votre système d'exploitation) à la racine du projet (l'endroit où se trouve le fichier "pom.xml"), vous pouvez :
\begin{itemize}
	\item Exécuter les tests via :
	\begin{lstlisting}[language=bash]
	$ mvn test
	\end{lstlisting}
	\item Compiler le projet en produisant une archive "jar" exécutable (inclus l'exécution des tests) via :
	\begin{lstlisting}[language=bash]
	$ mvn package
	\end{lstlisting}
	\item Générer le site Maven (inclus les étapes précédentes, la javadoc et des rapports d'analyse; le site généré étant accessible en ouvrant \nolinkurl{target/site/index.html}) via :
	\begin{lstlisting}[language=bash]
	$ mvn site
	\end{lstlisting}
	\item D'autres commandes sont évidemment disponibles pour, par exemple, générer la javadoc séparément mais ne sont pas reprises ici.
\end{itemize}

\subsection{Travis}
Puisque le projet JPacman dans son état \og initial \fg \, (avant modifications de notre part) intégrait déjà le fichier de configuration Travis\footnote{\url{https://travis-ci.org/}}, nous l'avons utilisé sur nos différents \og forks \fg .
L'historique des \og builds \fg \, (avec leurs logs) est disponible à l'adresse : \url{https://travis-ci.org/qdrien/jpacman-framework/builds}.

\subsection{Spécificités des ajouts individuels}
\subsubsection{Fonctionnalité "Série de labyrinthes"}
\begin{itemize}
	\item %todo: spécificités de config en référançant la section de début
\end{itemize}

%todo: note sur QUICK_WIN + "level generator" + convention de nommage des fichiers de level
%todo: note sur les branches git
%todo: note sur les tags des releases (+tagger la release finale!!!)
%todo: build la javadoc et l'ajouter au repo!!!
%todo: optimize imports/reformat code!!!
\section{Conclusion de l'analyse}





%\bibliographystyle{plain}
%\bibliography{bibliographie}
\end{document}